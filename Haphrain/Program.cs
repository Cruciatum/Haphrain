using System;
using System.IO;
using System.Reflection;
using System.Threading.Tasks;

using Discord;
using Discord.WebSocket;
using Discord.Commands;
using System.Linq;
using Microsoft.Extensions.DependencyInjection;
using Haphrain.Classes.HelperObjects;
using Haphrain.Classes.Data;
using System.Timers;
using System.Net.Http;

using System.Data.SqlClient;
using System.Collections.Generic;
using Haphrain.Classes.Commands;
using Haphrain.Classes.MortyGame;

namespace Haphrain
{
    internal class Program
    {
        private DiscordSocketClient Client;
        private CommandService Commands;
        private IServiceProvider Provider;
        private static readonly HttpClient httpClient = new HttpClient();
        internal static BotSettings bSettings;
        internal static DBSettings dbSettings;
        private Random r = new Random();
        private bool hasLoaded = false;

        static void Main(string[] args) => new Program().MainAsync().GetAwaiter().GetResult();

        private async Task MainAsync()
        {
            var res = Setup.GetFiles(bSettings, dbSettings);
            res.Wait();
            bSettings = res.Result.botSettings;
            dbSettings = res.Result.dbSettings;

            Client = new DiscordSocketClient(new DiscordSocketConfig
            {
                LogLevel = LogSeverity.Debug
            });

            Commands = new CommandService(new CommandServiceConfig
            {
                CaseSensitiveCommands = false,
                DefaultRunMode = RunMode.Async,
                LogLevel = LogSeverity.Debug
            });

            Provider = new ServiceCollection()
                .AddSingleton(Client)
                .AddSingleton(Commands)
                .BuildServiceProvider();

            Client.MessageReceived += Client_MessageReceived;
            await Commands.AddModulesAsync(Assembly.GetEntryAssembly(), null);

            Client.Ready += Client_Ready;
            Client.Log += Client_Log;
            Client.JoinedGuild += Client_JoinedGuild;
            Client.LeftGuild += Client_LeftGuild;
            Client.ReactionAdded += Client_ReactionAdded;
            Client.ReactionRemoved += Client_ReactionRemoved;

            if (!Directory.Exists(LogWriter.LogFileLoc.Replace($"Logs{Constants.slashType}Log", $"Logs{Constants.slashType}")))
            {
                Directory.CreateDirectory(LogWriter.LogFileLoc.Replace($"Logs{Constants.slashType}Log", $"Logs{Constants.slashType}"));
            }
            DBControl.dbSettings = dbSettings;

            await Client.LoginAsync(TokenType.Bot, bSettings.token);
            await Client.StartAsync();

            Timer t = new Timer();
            t.AutoReset = true;
            async void handler(object sender, ElapsedEventArgs e)
            {
                List<Poll> tempList = GlobalVars.Polls;
                foreach (Poll p in tempList)
                    await GlobalVars.Polls.Single(i=> i==p).Update();
            }
            t.StartTimer(handler, 5000);

            GlobalVars.CurrencyList = await Setup.GetCurrencies(Constants._CURRENCYLAYER_);
            GlobalVars.CurrencyLastUpdated = DateTime.Now;

            Timer CurT = new Timer();
            CurT.AutoReset = true;
            async void CurHandler(object sender, ElapsedEventArgs e)
            {
                GlobalVars.CurrencyList = await Setup.GetCurrencies(Constants._CURRENCYLAYER_);
                GlobalVars.CurrencyLastUpdated = DateTime.Now;
            }
            CurT.StartTimer(CurHandler, 86400000);

            GlobalVars.GameObj = new MortyGame(dbSettings);
            GlobalVars.Client = Client;
            
            await Task.Delay(-1);
        }

        private async Task GetSQLData()
        {
            if (hasLoaded)
                return;

            //Load prefix & options from DB
            SqlConnectionStringBuilder sBuilder = new SqlConnectionStringBuilder();
            sBuilder.InitialCatalog = dbSettings.db;
            sBuilder.UserID = dbSettings.username;
            sBuilder.Password = dbSettings.password;
            sBuilder.DataSource = dbSettings.host + @"\" + dbSettings.instance + "," + dbSettings.port;
            sBuilder.ConnectTimeout = 30;
            sBuilder.IntegratedSecurity = false;
            SqlConnection conn = new SqlConnection();

            conn.ConnectionString = sBuilder.ConnectionString;
            
            using (conn)
            {
                conn.Open();

                #region Get Guilds
                SqlCommand cmd = new SqlCommand($"SELECT * FROM Guilds", conn);
                SqlDataReader dr = cmd.ExecuteReader();

                while (dr.Read())
                {
                    GuildOption go = new GuildOption();
                    Options o = new Options();

                    go.GuildID = Convert.ToUInt64(dr.GetValue(0));
                    go.GuildName = Convert.ToString(dr.GetValue(1));
                    go.OwnerID = Convert.ToUInt64(dr.GetValue(2));
                    go.Prefix = Convert.ToString(dr.GetValue(3));
                    o.LogChannelID = Convert.ToUInt64(dr.GetValue(4));
                    o.LogEmbeds = Convert.ToBoolean(dr.GetValue(5));
                    o.LogAttachments = Convert.ToBoolean(dr.GetValue(6));

                    go.Options = o;

                    if (!GlobalVars.GuildOptions.Any(x => x.GuildID == go.GuildID))
                        GlobalVars.GuildOptions.Add(go);
                }
                dr.Close();
                #endregion

                #region Get Friends
                cmd.CommandText = $"SELECT UserID FROM Friends";
                dr = cmd.ExecuteReader();
                while (dr.Read())
                {
                    var id = Convert.ToUInt64(dr.GetValue(0));
                    var user = await CustomUserTypereader.GetUserFromID(id, Client.Guilds);
                    if (!GlobalVars.FriendUsers.ContainsKey(id))
                        GlobalVars.FriendUsers.Add(id, user);
                }
                dr.Close();
                #endregion

                #region Get Idiots
                cmd.CommandText = $"SELECT UserID FROM Ignores";
                dr = cmd.ExecuteReader();
                while (dr.Read())
                {
                    var id = Convert.ToUInt64(dr.GetValue(0));
                    var user = await Classes.Commands.CustomUserTypereader.GetUserFromID(id, Client.Guilds);
                    if (!GlobalVars.IgnoredUsers.ContainsKey(id))
                        GlobalVars.IgnoredUsers.Add(id, user);
                }
                dr.Close();
                #endregion

                #region Get Emotes
                cmd.CommandText = $"SELECT * FROM Emotes";
                dr = cmd.ExecuteReader();
                while (dr.Read())
                {
                    ApprovedEmote ae = new ApprovedEmote(dr.GetValue(0).ToString(),dr.GetValue(3).ToString(),dr.GetValue(2).ToString(),Convert.ToBoolean(dr.GetValue(4)), dr.GetValue(5).ToString(), Convert.ToBoolean(dr.GetValue(6)));
                    if (!GlobalVars.EmoteList.ContainsKey(ae.EmoteID))
                        GlobalVars.EmoteList.Add(ae.EmoteID, ae);
                }
                dr.Close();
                #endregion

                #region Get Bot Owners
                cmd.CommandText = $"SELECT * FROM BotOwners";
                dr = cmd.ExecuteReader();
                List<ulong> ownerList = new List<ulong>();
                while (dr.Read())
                {
                    ownerList.Add(Convert.ToUInt64(dr.GetValue(1)));
                }
                Constants._BOTOWNERS_ = ownerList.ToArray();
                dr.Close();
                #endregion

                #region Get Morty Users
                cmd.CommandText = $"SELECT * FROM mortyUsers";
                dr = cmd.ExecuteReader();
                List<ulong> mortyUsers = new List<ulong>();
                while (dr.Read())
                {
                    mortyUsers.Add(Convert.ToUInt64(dr.GetValue(1)));
                }
                GlobalVars.RegisteredMortyUsers = mortyUsers;
                GlobalVars.MortyTimeouts = new Dictionary<ulong, bool>();
                GlobalVars.MortyLastUse = new Dictionary<ulong, DateTime>();
                foreach (ulong u in GlobalVars.RegisteredMortyUsers)
                {
                    GlobalVars.MortyTimeouts.Add(u, false);
                    GlobalVars.MortyLastUse.Add(u, DateTime.MinValue);
                }
                dr.Close();
                #endregion

                #region Get Timers
                cmd.CommandText = $"SELECT UserID, GuildID, ChannelID, TimerType, TriggerTime, TimerMessage, TimerID FROM Timers";
                dr = cmd.ExecuteReader();
                
                List<TimerObj> timerList = new List<TimerObj>();

                while (dr.Read())
                {
                    var o = new TimerObj
                    {
                        UserID = ulong.Parse(dr.GetValue(0).ToString()),
                        GuildID = ulong.Parse(dr.GetValue(1).ToString()),
                        ChannelID = ulong.Parse(dr.GetValue(2).ToString()),
                        TimerType = dr.GetValue(3).ToString(),
                        TriggerTime = dr.GetValue(4).ToString(),
                        TimerMsg = dr.GetValue(5).ToString(),
                        TimerID = int.Parse(dr.GetValue(6).ToString())
                };
                    timerList.Add(o);
                }
                
                foreach (var o in timerList)
                {
                    if (o.TimerType == "remind")
                    {
                        Reminders r = new Reminders();
                        int time = 0;
                        List<string> timeParts = o.TriggerTime.Split('-').ToList();
                        timeParts.RemoveAll(s => s == "-");
                        int[] intTP = new int[7];
                        for (int i = 0; i < 7; i++)
                        {
                            intTP[i] = int.Parse(timeParts[i]);
                        }
                        DateTime dt = new DateTime(intTP[0], intTP[1], intTP[2], intTP[3], intTP[4], intTP[5], intTP[6]);
                        time = Convert.ToInt32(dt.Subtract(DateTime.Now).TotalMilliseconds);

                        if (time >= 0)
                        {
                            var t = Convert.ToUInt64(time);
                            var txtChan = Client.GetGuild(o.GuildID).GetTextChannel(o.ChannelID);
                            var u = Client.GetGuild(o.GuildID).GetUser(o.UserID);
                            var msg = o.TimerMsg.Replace("§²", "'").Replace("§³", ";");
                            r.TimerStart(t, txtChan, u, msg);
                        }
                        else
                        {
                            string sql = $"DELETE FROM Timers WHERE TimerID = {o.TimerID}";
                            DBControl.UpdateDB(sql);
                        }
                    }
                }

                dr.Close();
                #endregion

                conn.Close();
                conn.Dispose();
            }
        }

        private async Task Client_ReactionAdded(Cacheable<IUserMessage, ulong> cache, ISocketMessageChannel channel, SocketReaction reaction)
        {
            try
            {
                if (reaction.User.Value.Id == Client.CurrentUser.Id) return;
                var tMsg = GlobalVars.TrackedLogChannelMessages.SingleOrDefault(m => m.SourceMessage.Id == reaction.MessageId && m.TriggerById == reaction.UserId);
                var guildID = ((SocketGuildChannel)channel).Guild.Id;
                if (tMsg != null)
                {
                    if (reaction.Emote.Name == "✅")
                    {
                        GlobalVars.GuildOptions.Single(x => x.GuildID == guildID).Options.LogChannelID = channel.Id;
                        DBControl.UpdateDB($"UPDATE Guilds SET LogChannelID = {channel.Id.ToString()} WHERE GuildID = {guildID.ToString()};");
                        await reaction.Channel.SendMessageAsync($"{reaction.User.Value.Mention}: This channel ({MentionUtils.MentionChannel(channel.Id)}) is now your log channel.");
                        //Change channel topic
                    }
                    else if (reaction.Emote.Name == "🚫")
                    {
                        if (GlobalVars.GuildOptions.Single(x => x.GuildID == guildID).Options.LogChannelID == 0)
                            await reaction.Channel.SendMessageAsync($"{reaction.User.Value.Mention}: Please make a channel for logging and run the command again there.");
                        else
                            await reaction.Channel.SendMessageAsync($"Logging channel has not been changed.");
                    }
                }
                else
                {
                    tMsg = GlobalVars.TrackedSettingsMessages.SingleOrDefault(m => m.SourceMessage.Id == reaction.MessageId && m.TriggerById == reaction.UserId);
                    if (tMsg != null)
                    {
                        Options guildOptions = GlobalVars.GuildOptions.Single(x => x.GuildID == guildID).Options;
                        if (reaction.Emote.Name == "\u0031\u20E3")
                        {
                            guildOptions.LogEmbeds = !guildOptions.LogEmbeds;
                            DBControl.UpdateDB($"UPDATE Guilds SET LogEmbeds = {(guildOptions.LogEmbeds?1:0)} WHERE GuildID = {guildID};");
                            if (guildOptions.LogEmbeds)
                            {
                                await channel.SendMessageAsync("Now logging messages with embeds.");
                            }
                            else await channel.SendMessageAsync("No longer logging messages with embeds.");
                        }
                        else if (reaction.Emote.Name == "\u0032\u20E3")
                        {
                            guildOptions.LogAttachments = !guildOptions.LogAttachments;
                            DBControl.UpdateDB($"UPDATE Guilds SET LogAttachments = {(guildOptions.LogAttachments?1:0)} WHERE GuildID = {guildID};");
                            if (guildOptions.LogAttachments)
                            {
                                await channel.SendMessageAsync("Now logging messages with attachments.");
                            }
                            else await channel.SendMessageAsync("No longer logging messages with attachments.");
                        }
                    }
                    else
                    {
                        //Check other trackings
                    }
                }
                if (tMsg != null) { await GlobalVars.UntrackMessage(tMsg); return; }
                var p = GlobalVars.Polls.SingleOrDefault(x => x.PollMessage.Id == reaction.MessageId);
                if (p != null)
                {
                    bool? b = false;
                    if (p.PollReactions.SingleOrDefault(x => x.User.Id == reaction.User.Value.Id) == null)
                        b = p.AddReaction((SocketUser)reaction.User, p.PollOptions.SingleOrDefault(x => x.React.Name == reaction.Emote.Name).Option);
                    else
                        await p.PollMessage.RemoveReactionAsync(reaction.Emote, (SocketUser)reaction.User);
                    if (b != true)
                    {
                        await p.PollMessage.RemoveReactionAsync(reaction.Emote, (SocketUser)reaction.User);
                    }
                }
            }
            catch { }
        }

        private Task Client_ReactionRemoved(Cacheable<IUserMessage, ulong> cache, ISocketMessageChannel channel, SocketReaction reaction)
        {
            try
            {
                var poll = GlobalVars.Polls.SingleOrDefault(x => x.PollMessage.Id == reaction.MessageId);
                if (poll != null)
                {
                    bool? b = poll.RemoveReaction((SocketUser)reaction.User, poll.PollOptions.SingleOrDefault(x => x.React.Name == reaction.Emote.Name).Option);
                }
            }
            catch { }
            return Task.CompletedTask;
        }

        private async Task CheckGuildsStartup()
        {
            foreach (SocketGuild g in Client.Guilds)
            {
                if (GlobalVars.GuildOptions.SingleOrDefault(x => x.GuildID == g.Id) == null)
                {
                    await Client_JoinedGuild(g);
                }
            }
            foreach (GuildOption go in GlobalVars.GuildOptions)
            {
                if (Client.Guilds.SingleOrDefault(x => x.Id == go.GuildID) == null)
                {
                    DBControl.UpdateDB($"DELETE FROM Guilds WHERE GuildID = {go.GuildID};");
                }
            }
        }

        private async Task Client_LeftGuild(SocketGuild arg)
        {
            Console.WriteLine($"{DateTime.Now} -> Left guild: {arg.Id}");

            GlobalVars.GuildOptions.Remove(GlobalVars.GuildOptions.Single(x => x.GuildID == arg.Id));

            DBControl.UpdateDB($"DELETE FROM Guilds WHERE GuildID = {arg.Id};");

            await UpdateActivity();
            await Task.Delay(100);

        }

        private async Task Client_JoinedGuild(SocketGuild arg)
        {
            Console.WriteLine($"{DateTime.Now} -> Joined guild: {arg.Id}");

            GuildOption go = new GuildOption();
            Options o = new Options();

            go.GuildID = arg.Id;
            go.GuildName = arg.Name;
            go.OwnerID = arg.Owner.Id;
            go.Prefix = "]";
            o.LogChannelID = 0;
            o.LogEmbeds = false;
            o.LogAttachments = false;

            go.Options = o;
            if (!GlobalVars.GuildOptions.Any(x => x.GuildID == go.GuildID))
                GlobalVars.GuildOptions.Add(go);

            DBControl.UpdateDB($"INSERT INTO Guilds (GuildID,GuildName,OwnerID,Prefix,LogChannelID,LogEmbeds,LogAttachments) VALUES ({go.GuildID.ToString()}, '{go.GuildName.Replace(@"'","")}',{go.OwnerID.ToString()},'{go.Prefix}',{go.Options.LogChannelID.ToString()}, {(go.Options.LogEmbeds ? 1:0)}, {(go.Options.LogAttachments ? 1:0)});");

            await UpdateActivity();
            await Task.Delay(100);
        }

        internal static async Task Client_Log(LogMessage arg)
        {
            if (arg.Severity <= LogSeverity.Info)
            {
                if (arg.Exception != null)
                {
                    Console.WriteLine($"EXCEPTION [{arg.Severity.ToString()}]: {DateTime.Now} at {arg.Exception.Source} -> {arg.Exception.Message}");
                }
                Console.WriteLine($"[{arg.Severity.ToString().ToUpper()}]: {DateTime.Now} at {arg.Source} -> {arg.Message}");
            }
            if (arg.Exception != null)
            {
                await LogWriter.WriteLogFile($"EXCEPTION [{arg.Severity.ToString()}]: {DateTime.Now} {arg.Exception.Source} -> {arg.Exception.Message}");
            }
            await LogWriter.WriteLogFile($"[{arg.Severity.ToString().ToUpper()}]: {DateTime.Now} at {arg.Source} -> {arg.Message}");
        }

        private async Task Client_Ready()
        {
            await GetSQLData();
            await UpdateActivity();
            await CheckGuildsStartup();
            await Client_Log(new LogMessage(LogSeverity.Info, "Client_Ready", "Bot ready!"));
            hasLoaded = true;
        }

        private async Task Client_MessageReceived(SocketMessage arg)
        {
            var msg = arg as SocketUserMessage;
            var context = new SocketCommandContext(Client, msg);

            if (msg.Content.Length <= 1 && msg.Embeds.Count == 0 && msg.Attachments.Count == 0) return;
            if (context.User.IsBot) return;

            var guildOptions = GlobalVars.GuildOptions.Single(x => x.GuildID == context.Guild.Id);

            if ((context.Message == null || context.Message.Content == "") && arg.Attachments.Count == 0 && arg.Embeds.Count == 0) return;
            
            if (GlobalVars.IgnoredUsers.ContainsKey(context.User.Id)) return;

            //Get rid of Zero-Width Spaces
            context.Message.Content.Replace("\u200b", "");

            int argPos = 0;

            if (guildOptions.Options.LogChannelID != 0 && !msg.Content.StartsWith($"{guildOptions.Prefix}dm"))
            {
                if (guildOptions.Options.LogEmbeds)
                    if (msg.Embeds.Count > 0) { await ImageLogger.LogEmbed(msg, guildOptions.Options.LogChannelID, Client); }
                if (guildOptions.Options.LogAttachments)
                    if (msg.Attachments.Count > 0) { await ImageLogger.LogAttachment(msg, guildOptions.Options.LogChannelID, Client); }
            }

            if (!(msg.HasStringPrefix(guildOptions.Prefix, ref argPos, StringComparison.CurrentCultureIgnoreCase)) && !(msg.HasMentionPrefix(Client.CurrentUser, ref argPos))) return;


            if (!await GlobalVars.CheckUserTimeout(context.Message.Author, context.Guild.Id, context.Channel)) return;
            IResult Result = null;
            try
            {
                Result = await Commands.ExecuteAsync(context, argPos, Provider);
                if (Result.Error == CommandError.UnmetPrecondition)
                {
                    var errorMsg = await context.Channel.SendMessageAsync(Result.ErrorReason.Contains("USERMENTION")? Result.ErrorReason.Replace("USERMENTION",context.Message.Author.Mention): Result.ErrorReason);
                    GlobalVars.AddRandomTracker(errorMsg);
                }
                else if (!Result.IsSuccess)
                {
                    if (Result.ErrorReason.ToLower().Contains("unknown command"))
                    {
                        await Client_Log(new LogMessage(LogSeverity.Error, "Client_MessageReceived", $"Unknown command sent by {context.Message.Author.ToString()} in guild: {context.Guild.Id} - Command text: {context.Message.Content}"));
                    }
                    else if (Result.ErrorReason.ToLower().Contains("too many param"))
                    {
                        await Client_Log(new LogMessage(LogSeverity.Warning, "Client_MessageReceived", $"Invalid parameters sent by {context.Message.Author.ToString()} in guild: {context.Guild.Id} - Command text: {context.Message.Content}"));
                        var errorMsg = await context.Channel.SendMessageAsync($"Pretty sure you goofed on the parameters you've supplied there {context.Message.Author.Mention}!");
                        GlobalVars.AddRandomTracker(errorMsg);
                    }
                    else
                        await Client_Log(new LogMessage(LogSeverity.Error, "Client_MessageReceived", $"Command text: {context.Message.Content} | Error: {Result.ErrorReason}"));
                }
                var x = GlobalVars.UserTimeouts.SingleOrDefault(b => b.TrackedUser.Id == context.Message.Author.Id);
                if (x == null) GlobalVars.AddUserTimeout(context.Message.Author, context.Guild.Id);
            }
            catch (Exception ex)
            {
                await Client_Log(new LogMessage(LogSeverity.Critical, context.Message.Content, Result.ErrorReason, ex));
            }
        }

        private async Task UpdateActivity()
        {
            await Client.SetGameAsync($"{bSettings.activity.Replace("{count}", Client.Guilds.Count.ToString())} {bSettings.version}");
        }
    }

    internal class TimerObj
    {
        public int TimerID { get; set; }
        public ulong UserID { get; set; }
        public ulong GuildID { get; set; }
        public ulong ChannelID { get; set; }
        public string TimerType { get; set; }
        public string TriggerTime { get; set; }
        public string TimerMsg { get; set; }
    }
}